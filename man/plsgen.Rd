% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plsgen.r
\name{plsgen}
\alias{plsgen}
\title{plsgen}
\usage{
plsgen(block1, block2, plsn = 1, links1 = NULL, links2 = NULL,
  commonref = F, heatmap = F, heatcolors = c("blue4", "cyan2", "yellow",
  "red4"), triang1 = NULL, triang2 = NULL, alpha = 1, S1 = NA,
  S2 = NA, from1 = NULL, to1 = NULL, from2 = NULL, to2 = NULL,
  rounds = 0, sdx = 1, sdy = 1, labels = NULL, group = NULL,
  col = 1, colgroup = NULL, zlim2d = NULL)
}
\arguments{
\item{block1}{array: either a matrix of variables or an array of 3D or 2D shapes}

\item{block2}{array: either a matrix of variables or an array of 3D or 2D shapes}

\item{plsn}{numeric: which pair of PLS axes should be plotted}

\item{links1}{numeric:    links structure for shape 1}

\item{links2}{numeric: links structure for shape 2}

\item{commonref}{logical: if TRUE shapes are plotted on a common reference system. This is useful to plot results of analyses performed on Size and Shape Space.}

\item{heatmap}{logical: if TRUE heatmap is computed}

\item{heatcolors}{character: color palette for heatmap}

\item{triang1}{matrix: triangulation structure for shape 1 in 3D}

\item{triang2}{matrix: triangulation structure for shape 2 in 3D}

\item{alpha}{numeric: transparency parameter for heatmap}

\item{from1}{numeric: low range value for heatmap visualization in 3D for shape 1}

\item{to1}{numeric: max range value for heatmap visualization in 3D for shape 1}

\item{from2}{numeric: low range value for heatmap visualization in 3D for shape 2}

\item{to2}{numeric: max range value for heatmap visualization in 3D for shape 2}

\item{rounds}{numeric: permutation for pls2B() function from "Morpho" package for testing correlation between PLS axes pairs}

\item{sdx}{numeric: magnification parameter (in terms of standard deviation unit) for shape 1 visualization}

\item{sdy}{numeric: magnification parameter (in terms of standard deviation unit) for shape 1 visualization}

\item{labels}{character: labels to add to PLS plot}

\item{group}{character: group structure to be plotted in PLS plot and for computing means of PLS axes valeus}

\item{col}{numeric: points color in PLS plot}

\item{colgroup}{character: groups color in PLS plot}

\item{zlim2d}{numeeric: range of heatmap in 2D}

\item{S1=NA}{"S" argument from pslg() function in RTriangle package for shape 1 (if it is in 2D)}

\item{S2=NA}{"S" argument from pslg() function in RTriangle package for shape 1 (if it is in 2D)}

\item{pch}{numeric: points pch in PLS plot}
}
\value{
thepls list:	A pls2B object from pls2B() function from "Morpho" package

allxscores matrix:	Block1 scores

allyscores	matrix: Block2 scores

xscoresmeans	matrix: if group is provided group means for x scores

yscoresmeans	matrix: if group is provided group means for y scores
}
\description{
This function uses pls2B() function from "Morpho" package in order to illustrate results of two-blocks partial least squares applied to shape/shape, shape/matrix or matrix/matrix blocks. 3D/3D 2D/2D and 3D/2D visualizations are allowed. Heatmap is optionally computed. If a block is a matrix shape is not illustrated.
}
\examples{
\dontrun{ 
data(pri3d)
data(surf)
data(linksbase)
data(linksface)
data(linksentire)
data(sur_ent)
data(sur_fac)
data(sur_bas)
data(my2d)
data=pri3d
my3d<-centershapes(data)
amy3d<-procSym(my3d)
linksdors<-list(c(1,2),c(37,7),c(12,4),c(27,28),c(25,21),c(38,40),c(9,10),c(2,3),c(3,4),c(1,7),c(1,6),c(3,5),c(6,40),c(5,9),c(40,8),c(8,9),c(1,7),c(7,6),c(3,4),c(4,5),c(39,38),c(38,35),c(35,37),c(37,39),c(35,34),c(34,33),c(33,32),c(32,31),c(31,30),c(30,29),c(29,37),c(37,36),c(36,29),c(28,31),c(28,30),c(13,10),c(10,11),c(11,12),c(12,13),c(13,14),c(14,16),c(16,17),c(17,20),c(20,19),c(19,18),c(18,12),c(18,15),c(15,12),c(21,19),c(21,20),c(24,25),c(25,26),c(26,27),c(27,24),c(26,24),c(24,23),c(23,22),c(22,8),c(8,2))                                                                                                                                                           
amy2d<-procSym(my2d)
block1<-procSym(my2d[,,1:30])$orpdata
block2<-procSym(my2d[,,31:60])$orpdata
plsgen(block1,block2,links1=linksdors,links2=linksdors,commonref=T)
plsgen(block1,block2,links1=linksdors,links2=linksdors,commonref=F)
plsgen(block1,block2,links1=linksdors,links2=linksdors,commonref=F,heatmap=T)
block1<-procSym(my2d[,,1:30],,CSinit=T,scale=F)$orpdata
block2<-procSym(my3d[18:32,,1:30],CSinit=T,scale=F)$orpdata
plsgen(block1,block2,links1=linksdors,links2=linksface,heatmap=T,triang2=t(sur_fac$it),sdx=3)
block1<-procSym(my3d[1:17,,],CSinit=T,scale=F)$orpdata
block2<-procSym(my3d[18:32,,],CSinit=T,scale=F)$orpdata
plsgen(block1,block2,links1=linksbase,links2=linksface,commonref=T)
plsgen(block1,block2,commonref=T,triang1=t(sur_bas$it),heatmap=T,triang2=t(sur_fac$it),from1=0,from2=0,to1=0.051,to2=0.051)
block1<-procSym(my3d[1:17,,],CSinit=F,scale=F)$orpdata
block2<-procSym(my3d[18:32,,],CSinit=F,scale=F)$orpdata
plsgen(block1,block2,commonref=T,triang1=t(sur_bas$it),heatmap=T,triang2=t(sur_fac$it),from1=0,from2=0,to1=16,to2=16)
block1<-matrix(rnorm(1000,0,1),ncol=10)
block2<-matrix(rnorm(1000,0,1),ncol=10)
plsgen(block1,block2)
block1<-procSym(my3d[1:17,,1:30])$orpdata
block2<-as.matrix(cbind(procSym(my3d[1:17,,1:30])$size,rnorm(30,0,1)))
plsgen(block1,block2,links1=linksbase,heatmap=T,triang1=t(sur_bas$it))
}
}
\author{
Paolo Piras
}
